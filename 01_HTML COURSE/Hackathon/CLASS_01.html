<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Introduction to Web Development</title>
    <link rel="shortcut icon" href="Images/favicon.png" type="image/x-icon">
  </head>
  <body>
    <a href="index.html"><p>&larr; Back To Home</p></a>

    <h1>Web Development Course</h1>
    <br /><br />
    <iframe
      src="https://www.youtube.com/embed/1pcikNlDB-4"
      height="400px"
      width="700px"
      allowfullscreen
      title="Introduction To Web Development"
    ></iframe>
    <h2>HOW Does Internet Work</h2>
    <br />
    <h3>Principle 1: The Need to Share Information</h3>
    <p>
      The most fundamental truth is that we have information on one computer
      (Computer A) and we want it to be on another computer (Computer B). These
      computers are not in the same room.
    </p>
    <p>
      How do we solve this? The simplest, most primitive way is to physically
      carry the information (e.g., on a USB stick). This works, but it's slow
      and doesn't scale. We need a direct, electronic connection.
    </p>
    <p>
      So, we run a cable (like an ethernet cable or a fiber optic line) between
      Computer A and Computer B. We can now send electrical signals or pulses of
      light down this cable. We can agree on a simple code: a high-voltage
      signal means "1," and a low-voltage signal means "0."
    </p>
    <p>
      We have just created the most basic form of a network: a
      <strong>direct link.</strong> We can now send bits (1s and 0s) between two
      computers.
    </p>

    <h3>Principle 2: The Problem of Scale</h3>
    <p>
      This works for two computers. But what if we have three computers (A, B,
      and C) and they all need to talk to each other? We would need a cable from
      A to B, from B to C, and from A to C. For four computers, we'd need six
      cables. For 100 computers, we'd need 4,950 cables.
    </p>
    <p>
      This is a failure of scale. Connecting every machine to every other
      machine directly is physically impossible.
    </p>
    <p>
      The logical solution is to have a central device. Every computer connects
      to this one central point (let's call it a <strong>Switch</strong>). When
      Computer A wants to talk to Computer C, it sends the message to the
      switch, and the switch forwards it only to Computer C.
    </p>
    <p>
      We have just invented a <strong>Local Network.</strong> A group of
      computers in close proximity (like an office or a home) can now
      communicate efficiently.
    </p>

    <h3>Principle 3: The Problem of Connecting Networks</h3>
    <p>
      Now, our office has a local network. Another office across town also has
      its own local network. How does a computer on our network talk to a
      computer on their network?
    </p>
    <p>
      We face the same scaling problem. We can't run a wire from every computer
      in our office to every computer in theirs.
    </p>
    <p>
      The logical solution is to connect the networks themselves. We need a
      special, dedicated computer that is connected to our network and also
      connected to their network. Its only job is to pass messages, or "route"
      traffic, from one network to the other. Let's call this device
      <strong>Router.</strong>
    </p>
    <p>
      Now, if we want to connect to a third network, we just connect our router
      to their router. Suddenly, we can build a massive, sprawling web by
      connecting networks to other networks.
    </p>
    <p>
      This is the fundamental truth of the Internet. The
      <strong>Internet is a "network of networks."</strong> It is not one giant
      cloud; it is millions of private and public local networks all connected
      by these special routing devices.
    </p>

    <h3>Principle 4: The Problem of Finding Anyone (Addressing)</h3>
    <p>
      We have built a global web of interconnected networks. If I'm on my
      computer in my office, how do I send a message to a specific server in
      another country? There are millions of computers. I need a unique address
      for every single device.
    </p>
    <p>
      This gives rise to the need for a universal addressing system. Just like
      the postal service needs a unique street address for every house in the
      world, our network of networks needs a unique address for every connected
      device.
    </p>
    <p>
      This is the reason the
      <strong>IP Address (Internet Protocol Address)</strong> exists. It's a
      unique label (e.g., 142.250.184.142) assigned to each device. When a
      router sees a message, it looks at the destination IP address and says,
      "Based on this address, I don't need to send it to the network on my left;
      I need to send it to the network on my right to get it one step closer to
      its final destination." Routers don't know the full path; they just know
      the next best "hop" to send the message on.
    </p>

    <h3>Principle 5: The Problem of Reliability and Fairness</h3>
    <p>
      If I want to send a large file, like a 1-hour video, it is a huge stream
      of data. If I try to send it all at once:
    </p>
    <ol>
      <li>
        I would completely monopolize the connection, and no one else could send
        anything until my video was done.
      </li>
      <li>
        If even a single bit of information gets corrupted during the transfer,
        the entire file is ruined, and I have to start over from the beginning.
      </li>
    </ol>
    <p>
      This is inefficient and unreliable. The logical solution is to break the
      large file into many thousands of small, numbered pieces. Let's call them
      <strong>Packets.</strong>
    </p>
    <ul>
      <li>A small piece of the data (a "payload").</li>
      <li>The destination IP address (where it's going).</li>
      <li>The sender's IP address (so they can reply).</li>
      <li>
        A number, so the receiving computer knows how to reassemble them in the
        correct order ("Packet 1 of 5,000," "Packet 2 of 5,000," etc.).
      </li>
    </ul>
    <p>
      These packets can travel independently across the internet, sometimes even
      taking different routes. The receiving computer gathers all the packets,
      checks if any are missing (and requests them again if they are), and
      reassembles them in the correct order to recreate the original file.
    </p>
    <p>
      This system of rules for addressing, breaking down, sending, and
      reassembling data is called a <strong>Protocol.</strong> The main one used
      on the internet is
      <strong
        >TCP/IP (Transmission Control Protocol / Internet Protocol).</strong
      >
    </p>
    <hr />

    <h3>Summary from First Principles</h3>
    <p>
      So, the internet isn't magic. It's a series of logical solutions to a
      series of fundamental problems:
    </p>
    <ol>
      <li>
        <pre><strong>Problem:</strong> Share data between two computers. <strong>Solution:</strong> A <strong>direct physical link.</strong></pre>
      </li>
      <li>
        <pre><strong>Problem:</strong> Connect many computers efficiently. <strong>Solution:</strong> A <strong>local network</strong> with a central switch.</pre>
      </li>
      <li>
        <pre><strong>Problem:</strong> Connect many networks efficiently. <strong>Solution:</strong> An <strong>internetwork</strong> connected by <strong>routers.</strong></pre>
      </li>
      <li>
        <pre><strong>Problem:</strong> Find a specific computer in this massive web. <strong>Solution:</strong> A universal <strong>IP Address</strong> for every device.</pre>
      </li>
      <li>
        <pre><strong>Problem:</strong> Send data reliably and fairly without errors. <strong>Solution:</strong> A set of rules (<strong>TCP/IP</strong>) to break data into small, addressed <strong>packets</strong> that can be reassembled.</pre>
      </li>
    </ol>

    <h2>IP Address</h2>
    <p>
      An <strong>IPv4 (Internet Protocol version 4)</strong> address is the
      classic IP address format everyone is used to seeing.
    </p>
    <ul>
      <li>
        <strong>Structure:</strong> It's a 32-bit number. To make it readable
        for humans, we divide it into four 8-bit sections, and write each
        section as a decimal number from 0 to 255.
        <ul>
          <li>Example: 172.217.16.142 (one of Google's addresses)</li>
        </ul>
      </li>
      <li>
        <strong>The Big Problem (The Why):</strong> A 32-bit number means
        there's a hard limit on the total number of possible addresses: 2^32,
        which is about
        <strong>4.3 billion.</strong>
      </li>
    </ul>
    <p>
      When the internet was designed, 4.3 billion seemed like an infinite
      number. But with the explosion of laptops, phones, servers, smart watches,
      and even smart refrigerators, we quickly realized we would run out. This
      scarcity is the <strong>single most important reason</strong> we have
      public and private IPs.
    </p>

    <h3>Public IP Address</h3>
    <p>
      A Public IP address is your
      <strong>global, unique address on the internet.</strong>
    </p>
    <ul>
      <li>
        <strong>Analogy:</strong> The company's main, public phone number.
      </li>
      <li>
        <strong>Uniqueness:</strong> It must be
        <strong>globally unique.</strong> No two devices on the internet can
        have the same public IP address at the same time.
      </li>
      <li>
        <strong>Purpose:</strong> To be reachable from anywhere in the world.
        This is the address that web servers, email servers, and any other
        public service use.
      </li>
      <li>
        <strong>Assignment:</strong> It is assigned to you by your
        <strong>Internet Service Provider (ISP)</strong> (Comcast, AT&T, etc.).
        You don't control it; you lease it from them.
      </li>
      <li>
        <strong>Who has one?</strong> Your home router has one. The server
        hosting google.com has one. The server hosting Netflix has one.
      </li>
    </ul>
    <p>
      When you go to a site like whatismyip.com, it shows you the Public IP
      address of your router. From the internet's perspective, your entire home
      network looks like a single device with that one public address.
    </p>

    <h3>Private IP Address</h3>
    <p>
      A Private IP address is a
      <strong>local address used only within your own private network</strong>
      (e.g., your home Wi-Fi, your office network).
    </p>
    <ul>
      <li>
        <strong>Analogy:</strong> The employee's private, 4-digit extension
        number.
      </li>
      <li>
        <strong>Uniqueness:</strong> It only needs to be unique
        <strong>on your local network.</strong> My laptop can have the address
        192.168.1.100 on my home Wi-Fi, and your laptop can have the exact same
        address on your home Wi-Fi. They don't conflict because they are in
        separate, private networks.
      </li>
      <li>
        <strong>Purpose:</strong>
        To allow devices on the same local network to communicate with each
        other without needing a globally unique address for each one. Your
        laptop talks to your printer using private IPs. Your phone streams to
        your Chromecast using private IPs.
      </li>
      <li>
        <strong>Assignment:</strong> It is assigned to your devices by your own
        <strong>router.</strong>
      </li>
      <li>
        <strong>Reserved Ranges:</strong>
        The internet authorities have reserved specific ranges of addresses just
        for this purpose. If you see an IP address starting with one of these,
        you know it's a private address:
        <ul>
          <li>10.0.0.0 to 10.255.255.255 (Used by large corporations)</li>
          <li>172.16.0.0 to 172.31.255.255 (Used by medium-sized networks)</li>
          <li>
            192.168.0.0 to 192.168.255.255 (Most common for home networks)
          </li>
        </ul>
      </li>
    </ul>

    <h3>IPv6</h3>
    <p>
      <strong>IPv6 (Internet Protocol version 6)</strong> is the next generation
      of the Internet Protocol. Its primary purpose was to solve the address
      exhaustion problem of IPv4.
    </p>
    <br />
    <p>The fundamental difference is the size of the address:</p>
    <ul>
      <li>
        <strong>IPv4:</strong> Uses a <strong>32-bit</strong> address, giving us
        ~4.3 billion unique addresses.
      </li>
      <li><strong>IPv6:</strong> Uses a <strong>128-bit</strong> address.</li>
    </ul>
    <p>
      The difference between 32-bit and 128-bit is not 4x. It's an exponential
      leap that is difficult to comprehend.
    </p>
    <p>The number of possible IPv6 addresses is 2^128, which is roughly:</p>
    <p><strong>340,000,000,000,000,000,000,000,000,000,000,000,000</strong></p>
    <p>(340 undecillion)</p>

    <h3>What Does an IPv6 Address Look Like?</h3>
    <p>
      Because it's so long, the format is different. It uses
      <strong>hexadecimal</strong> (numbers 0-9 and letters a-f) instead of just
      decimal numbers.
    </p>
    <p>An example of a full IPv6 address:</p>
    <p>2001:0db8:85a3:0000:0000:8a2e:0370:7334</p>
    <p>It's broken down into:</p>
    <ul>
      <li>Eight groups of four hexadecimal characters.</li>
      <li>The groups are separated by colons (:).</li>
    </ul>

    <h2>MAC Address:</h2>
    <p>
      A <strong>MAC (Media Access Control) Address</strong> is a unique,
      permanent serial number burned into every network-capable piece of
      hardware (your laptop's Wi-Fi card, your phone, your smart TV, the network
      port on your desktop).
    </p>
    <br />
    <p>
      To track you, if you get offline and someone get the ip, they will get
      your message.
    </p>
    <br />
    <p>
      A MAC address is a <strong>48-bit</strong> number. To make it readable for
      humans, it's typically written as <strong>12 hexadecimal digits.</strong>
    </p>
    <p>The most common ways you'll see it displayed are:</p>
    <ol>
      <li>
        <p>
          <strong
            >Colon-Separated (Most Common):Colon-Separated (Most
            Common):</strong
          >
        </p>
        <p>3C:22:FB:A3:B4:C5</p>
      </li>
      <li>
        <p><strong>Hyphen-Separated (Common on Windows):</strong></p>
        <p>3C-22-FB-A3-B4-C5</p>
      </li>
      <li>
        <p>
          <strong
            >Period-Separated (Used by Cisco and other network gear):</strong
          >
        </p>
        <p>3c22.fba3.b4c5</p>
      </li>
      <li>
        <p>
          <strong>No Separators (Less common, seen in some software):</strong>
        </p>
        <p>3C22FBA3B4C5</p>
      </li>
    </ol>

    <h3>How to Find MAC Address</h3>

    <h4>Windows</h4>
    <ol>
      <li>
        <strong>Open Command Prompt:</strong>
        <ul>
          <li>Click the <strong>Start Menu.</strong></li>
          <li>Type cmd and press <strong>Enter.</strong></li>
          <li>
            (Alternatively, press Win + R, type cmd, and press
            <strong>Enter</strong>).
          </li>
        </ul>
      </li>
      <li>
        <strong>Run the Command:</strong>Code
        <ul>
          <li>
            In the black window that appears, type the following command and
            press <strong>Enter:</strong>
          </li>
          <pre>  <code>ipconfig /all</code></pre>
        </ul>
      </li>
    </ol>
    <p>
      If you only want to see the MAC addresses without all the other details,
      you can use the getmac command.
    </p>
    <pre>   <code>getmac /v</code></pre>

    <h4>MACOS</h4>
    <ol>
      <li>
        <strong>Open Terminal:</strong>
        <ul>
          <li>Open <strong>Spotlight Search</strong> (press Cmd + Space).</li>
          <li>Type Terminal and press <strong>Enter.</strong></li>
        </ul>
      </li>
      <li>
        <strong>Run the Command:</strong>codeCode
        <ul>
          <li>
            In the window that appears, type the following command and press
            <strong>Enter:</strong>
          </li>
          <pre>    <code>ifconfig</code></pre>
        </ul>
      </li>
    </ol>

    <h2>Port Number</h2>
    <p>
      Port numbers are
      <b
        >numerical identifiers (0-65535) in computer networking that identify
        specific applications or services on a device.</b
      >
      They work with IP addresses to direct network traffic to the correct
      service on a machine, with common ports assigned to standard applications
      like HTTP (port 80) and HTTPS (port 443).
    </p>
    <p>A port number is a <strong>16-bit unsigned integer.</strong></p>
    <p>Let's break that down:</p>
    <ul>
      <li>
        <strong>16-bit:</strong> This means the number is stored using 16 binary
        digits (1s and 0s).
      </li>
      <li>
        <strong>Unsigned:</strong> This means it cannot be negative. The values
        are all positive.
      </li>
    </ul>
    <p>
      Because it's a 16-bit number, the total number of possible ports is 2^16,
      which equals <strong>65,536.</strong>
    </p>

    <h3>The Practical Format: The Three Categories</h3>
    <p>
      To prevent chaos, the internet authorities (IANA) have divided the 65,536
      available ports into three categories. This is the most practical format
      for you as a developer to understand.
    </p>
    <h4>1. Well-Known Ports (Range: 0 - 1023)</h4>
    <p>
      These are the VIPs of the port world. They are reserved for the most
      common, fundamental, and standardized internet services.
    </p>
    <ul>
      <li><strong>Controlled By:</strong> Strictly managed by IANA.</li>
      <li>
        <strong>Privileges:</strong> On most operating systems (like Linux and
        macOS), you need administrator (root or sudo) privileges to run a
        program that listens on these ports. This is a security measure to
        prevent rogue applications from impersonating standard services.
      </li>
      <li>
        <strong>Key Examples for a Developer:</strong>
        <ul>
          <li>21: FTP (File Transfer Protocol)</li>
          <li>
            22: <strong>SSH</strong> (Secure Shell) - How you will log into your
            servers.
          </li>
          <li>25: SMTP (Simple Mail Transfer Protocol) - For sending email.</li>
          <li>53: DNS (Domain Name System)</li>
          <li>
            80: <strong>HTTP</strong> (HyperText Transfer Protocol) - The
            standard for unencrypted web traffic.
          </li>
          <li>
            443: <strong>HTTPS</strong> (HTTP Secure) - The standard for
            encrypted web traffic.
          </li>
        </ul>
      </li>
    </ul>

    <h4>2. Registered Ports (Range: 1024 - 49151)</h4>

    <p>
      These ports are for specific applications or services that are not as
      universal as the "well-known" ones. Companies and developers can register
      a port for their software to avoid conflicts with other applications.
    </p>

    <ul>
      <li>
        <strong>Controlled By:</strong> Less strict. You can request a port from
        IANA.
      </li>
      <li>
        <strong>Privileges:</strong> You do <strong>not</strong> need
        administrator privileges to use these ports. This is the "user space"
        for applications.
      </li>

      <li>
        <strong>Key Examples for a MERN Developer:</strong>
        <ul>
          <li>
            3000: The unofficial but extremely common default for running
            <strong>React and Node.js development servers</strong>. You will use
            this <em>constantly</em>.
          </li>
          <li>3306: MySQL databases.</li>
          <li>5432: PostgreSQL databases.</li>
          <li>
            27017: The default port for <strong>MongoDB</strong>, the database
            in the MERN stack.
          </li>
          <li>
            8080: A very common alternative port for web servers during
            development.
          </li>
        </ul>
      </li>
    </ul>

    <h4>3. Dynamic / Private / Ephemeral Ports (Range: 49152 - 65535)</h4>

    <p>
      These ports are not meant for public-facing servers. Their job is
      completely different.
    </p>

    <ul>
      <li>
        <strong>Controlled By:</strong> No one. They are for temporary, private
        use.
      </li>
      <li>
        <strong>Purpose:</strong> When your web browser (the client) makes a
        request to a server (e.g., to google.com on port 443), your computer's
        operating system needs to assign a temporary
        <strong>source port</strong> for its side of the conversation. It grabs
        a random, unused port from this high-numbered range for the duration of
        that single connection.
      </li>
      <li>
        <strong>Key Takeaway:</strong> You never configure your server
        applications to listen on these ports. They are used automatically by
        the client side of a connection.
      </li>
    </ul>

    <h2>DNS(DOMAIN NAME SYSTEM)</h2>
    <p>
      DNS is the global, distributed system that translates the human-friendly
      domain names into the computer-friendly IP addresses. Without it, you'd
      have to memorize hundreds of IP addresses to browse the web.
    </p>
    <h3>Step 1: Checking the Local Cache (Do I already know this?)</h3>

    <p>
      Before your computer does any work, it checks if it already has the
      answer. Speed is everything. It checks in this order:
    </p>

    <ol>
      <li>
        <strong>Browser Cache:</strong> The browser itself keeps a short-term
        memory of recently visited websites. If you were just at
        <em>google.com</em> five minutes ago, the answer is probably here.
      </li>
      <li>
        <strong>Operating System (OS) Cache:</strong> If the browser doesn't
        have it, your OS (Windows, macOS, Linux) also has a cache.
      </li>
      <li>
        <strong>Router Cache:</strong> Some routers also maintain their own DNS
        cache.
      </li>
    </ol>

    <p>
      If the IP address is found in any of these caches, the process stops here,
      and your browser immediately connects to the IP address. This is why
      websites you visit often load so quickly.
    </p>

    <h3>Step 2: The Recursive Resolver (Asking for Help)</h3>

    <p>
      If the answer isn't in any local cache, your computer needs to ask for
      help. It sends a query to its configured
      <strong>Recursive DNS Resolver</strong>.
    </p>

    <ul>
      <li>
        <strong>Who is this?</strong> This is usually a server run by your
        <strong>ISP</strong>. Alternatively, you might use a public one like
        Google's (<code>8.8.8.8</code>) or Cloudflare's (<code>1.1.1.1</code>).
      </li>
      <li>
        <strong>What does "Recursive" mean?</strong> It means this server
        promises to do all the hard work to find the final answer on your
        behalf. It will "recurse" through the internet's DNS hierarchy until it
        finds what you're looking for.
      </li>
    </ul>

    <h3>Step 3: The Hierarchical Search (The Global Phonebook)</h3>

    <p>
      The Recursive Resolver doesn't know every IP address in the world.
      Instead, it knows how to navigate the global DNS system, which is a giant,
      hierarchical tree. It starts from the top and works its way down.
    </p>

    <ol>
      <li>
        <strong>The Root Servers:</strong> The resolver first asks one of the 13
        logical <strong>Root Servers</strong> in the world. It doesn't ask "What
        is the IP for <em>www.google.com</em>?". It asks a simpler question:
        "Hey, where can I find the servers that manage the
        <em>.com</em> domain?"
        <ul>
          <li>
            The Root Server replies: "I don't know about <em>google.com</em>,
            but here is the address for the <em>.com</em>
            <strong>TLD servers</strong>."
          </li>
        </ul>
      </li>
      <li>
        <strong>The TLD Servers:</strong> The resolver now asks one of the
        <strong>Top-Level Domain (TLD) Servers</strong> for <em>.com</em>.
        Again, it asks a simple question: "Hey, where can I find the servers
        that are in charge of the <em>google.com</em> domain?"
        <ul>
          <li>
            The TLD Server replies: "I don't know the IP for
            <em>www.google.com</em> specifically, but I know who does. The
            official, authoritative servers for <em>google.com</em> are at these
            addresses (e.g., <em>ns1.google.com</em>)."
          </li>
        </ul>
      </li>
      <li>
        <strong>The Authoritative Name Server:</strong> This is the final step.
        The resolver asks one of Google's own
        <strong>Authoritative Name Servers</strong>. This server is the
        <strong>source of truth</strong> for the <em>google.com</em> domain. It
        asks the final question: "What is the IP address for
        <em>www.google.com</em>?"
        <ul>
          <li>
            The Authoritative Server checks its records and gives the final
            answer:
            <strong
              >"The IP address for <em>www.google.com</em> is
              142.250.72.206."</strong
            >
          </li>
        </ul>
      </li>
    </ol>

    <h3>Step 4: The Journey Back</h3>

    <ol>
      <li>
        The Authoritative Server sends the IP address back to the Recursive
        Resolver.
      </li>
      <li>
        The <strong>Recursive Resolver saves (caches) this answer</strong> for a
        period of time (called the TTL or Time-To-Live). If anyone else asks it
        for <em>google.com</em> in the next few hours, it can answer instantly
        without doing the whole search again.
      </li>
      <li>
        The Recursive Resolver sends the IP address back to your computer's
        operating system.
      </li>
      <li>Your OS gives the IP to your browser.</li>
    </ol>

    <h3>Step 5: The Final Connection</h3>

    <p>
      Now, finally, your browser has the IP address it needs. It can now open a
      direct connection to <code>142.250.72.206</code> on port
      <strong>443</strong> (for HTTPS) and say, "Please send me the webpage for
      <em>www.google.com</em>."
    </p>

    <p>The DNS process is complete.</p>

    <h2>Summary by Images</h2>
    <img src="Images/class_1-content-img.png" width="700px" alt="summary image" />
  </body>
</html>
